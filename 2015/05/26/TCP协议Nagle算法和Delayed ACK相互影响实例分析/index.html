<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【原创】TCP协议Nagle算法和Delayed ACK相互影响实例分析 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="建议：阅读本文之前，最好对于TCP的发送、重发以及ACK机制有所了解。
##问题描述最近在一个消息中间件系统（该消息中间件由客户端SDK和服务端Server组成）的性能测试时，发现每个请求的响应时间大概在40ms-50ms之间，这明显过大了。最终定位，是因为SDK没有禁用TCP的Nagle算法导致的">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="【原创】TCP协议Nagle算法和Delayed ACK相互影响实例分析"/>
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Hexo</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">		
			<h1> 【原创】TCP协议Nagle算法和Delayed ACK相互影响实例分析</h1>
		</div>		
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p><em>建议：阅读本文之前，最好对于TCP的发送、重发以及ACK机制有所了解。</em></p>
<p>##问题描述<br>最近在一个消息中间件系统（该消息中间件由客户端SDK和服务端Server组成）的性能测试时，发现每个请求的响应时间大概在40ms-50ms之间，这明显过大了。最终定位，是因为SDK没有禁用TCP的Nagle算法导致的。但其根本原理是因为TCP的Delayed Ack机制和Nagle Algorithm相互影响导致的。</p>
<p>##概念详解<br><strong>TCP-Delayed Ack</strong></p>
<blockquote>
<p>目的：用于防止只发送一个单独的Ack包，而是希望发送的包是一个Ack+一份数据组成一个包，这样能较少交互次数，减少网络资源消耗。这个设定是基于对于一般交互场景的一个基本假设：数据接收方会生成一个响应给数据发送方。<br>原理：当数据接收方收到一个TCP包之后，先不回应ACK包，而是等待一定的时间（本例中是40ms），直到</p>
<ol>
<li>数据接收方发送一份响应数据<br>当数据接收方，收到足够的数据，进行业务处理后，一般会返回业务响应，这时会立即返回：业务响应+ACK。</li>
<li>接收到连续的TCP包<br>当服务接收端接收到1号TCP包后，会先延迟发送1号包的ACK，等待2号包到来，2号包到达时，则立即返回一次ACK；当3号包到来时，会延迟3号包的ACK，等待4号包到来，4号包到达时，则立即返回一次ACK……<br>那么，这样就造成偶数序号的TCP包到达的时候，就会立即返回一次ACK；而奇数序号的包到达时，则延迟ACK响应，等待后续的偶数包到来。</li>
<li>超时<br>超过40ms。</li>
</ol>
</blockquote>
<p><strong>TCP-Nagle Algorithm</strong></p>
<blockquote>
<p>目的：用于防止发送大量的小包，降低网络资源消耗。<br>原理：当数据发送方写入TCP缓冲区的数据小于MSS（最大报文长度），则暂不发送，等待写入的数据达到MSS再发送；除非在等待的过程中，发送端发送出去的所有TCP报文均已被ACK，这样就可以不用等待写入数据达到MSS，直接发送出去了。我们称没有达到MSS的报文为小包的话，那么其实TCP-Nagle Algorithm就保证了一个连接在一个时刻，有且只能有一个没有被确认的小包。<br>关于以上两点，可以参考这篇文章，介绍的很详细：<a href="http://www.stuartcheshire.org/papers/NagleDelayedAck/" target="_blank" rel="external">http://www.stuartcheshire.org/papers/NagleDelayedAck/</a></p>
</blockquote>
<p>##过程分析<br>该消息中间件系统在做性能测试时，SDK没有禁用Nagle算法，而Server端禁用了；测试时的消息长度为消息头（12）+消息体（14）Byte，TCP MSS是1460Byte；服务端和SDK交互采用类似TCP三次握手的确认机制来保证高可靠性。那么考虑如下过程：</p>
<blockquote>
<ol>
<li>SDK端发送第一条消息，写入了TCP Buffer，虽然未达到MSS，但是因为没有需要确认的包，所以会立即发送；</li>
<li>Server端收到TCP包后，就延迟ACK响应；同时SDK端由于启用了Nagle算法，并且存在没有ACK的包，因此处于等待中；</li>
<li>Server端业务层解包进行业务处理，处理完成后，立即发送业务响应，并捎带ACK返回给SDK；</li>
<li>SDK端收到了Server端返回的响应和ACK后，立即回复业务确认消息，并捎带ACK；</li>
<li>由于Server端收到业务确认消息后，不用再返回响应给SDK，因此延迟ACK确认；</li>
<li>SDK端发送第二条消息，但是因为启用了Nagle算法，所以必须等待ACK。直到第5步的延迟确认到达，则立即发送第二条消息。</li>
</ol>
</blockquote>
<p>Tcpdump抓包如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-05-25 18:42:49.736897 IP 100.84.52.90.58237 &#62; 100.84.73.45.9090: P 71:101(30) ack 20 win 16420&#10;E..FU3@.=..OdT4ZdTI-.&#125;#...(.R.mpP.@$.).......)....&#10;queueAThis is test &#10;2015-05-25 18:42:49.737763 IP 100.84.73.45.9090 &#62; 100.84.52.90.58237: P 20:39(19) ack 101 win 46&#10;E..;Fn@.@...dTI-dT4Z#..&#125;R.mp..)&#9;P...F].......*......SUCCESS&#10;2015-05-25 18:42:49.744738 IP 100.84.52.90.58237 &#62; 100.84.73.45.9090: P 101:113(12) ack 39 win 16415&#10;E..4U4@.=..`dT4ZdTI-.&#125;#...)&#9;R.m.P.@.d........4......&#10;2015-05-25 18:42:49.784810 IP 100.84.73.45.9090 &#62; 100.84.52.90.58237: . ack 113 win 46&#10;E..(Fo@.@..1dTI-dT4Z#..&#125;R.m...).P.......&#10;2015-05-25 18:42:49.785438 IP 100.84.52.90.58237 &#62; 100.84.73.45.9090: P 113:143(30) ack 39 win 16415&#10;E..FU5@.=..MdT4ZdTI-.&#125;#...).R.m.P.@..........)....&#10;queueAThis is test &#10;2015-05-25 18:42:49.785450 IP 100.84.73.45.9090 &#62; 100.84.52.90.58237: . ack 143 win 46&#10;E..(Fp@.@..0dTI-dT4Z#..&#125;R.m...)3P.......&#10;2015-05-25 18:42:49.786147 IP 100.84.73.45.9090 &#62; 100.84.52.90.58237: P 39:58(19) ack 143 win 46&#10;E..;Fq@.@...dTI-dT4Z#..&#125;R.m...)3P...F].......*......SUCCESS&#10;2015-05-25 18:42:49.790470 IP 100.84.52.90.58237 &#62; 100.84.73.45.9090: P 143:173(30) ack 58 win 16410&#10;E..(Fo@.@..1dTI-dT4Z#..&#125;R.m...).P.......</span><br></pre></td></tr></table></figure></p>
<p><strong>总结：通过以上过程可以发现，由于第5步的延迟ACK，导致SDK发送消息延迟，最终导致了性能下降。如果SDK端关闭的Nagle算法，SDK就可以立即发送第二条消息，而不会受到Nagle算法的约束，一直等待第5步的ACK到达。</strong></p>
<p>##代码说明<br>在Netty中，可以通过设置tcpNoDelay选项，开启或者禁用Nagle算法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来禁用TCP的Nagle算法。</span></span><br><span class="line">bootstrap.setOption(<span class="string">"tcpNoDelay"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Netty底层其实就是使用JDK中的Socket.class的setTcpNoDelay方法来设置。</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Enable/disable TCP_NODELAY (disable/enable Nagle's algorithm).</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTcpNoDelay</span><span class="params">(<span class="keyword">boolean</span> on)</span> <span class="keyword">throws</span> SocketException</span>;</span><br></pre></td></tr></table></figure></p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2015/05/28/Netty中ChannelHandler共享数据的方式/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>上一頁</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2015/05/25/从无到有：软件项目过程实践/" class="alignright next">下一頁<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">留言</h2>

  
</section>

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2015-05-26 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/协议/">协议<span>1</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Netty/">Netty<span>4</span></a></li> <li><a href="/tags/TCP/">TCP<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
